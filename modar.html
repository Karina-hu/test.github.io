<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>AR Скалярное произведение векторов</title>
    <script src="https://cdn.jsdelivr.net/npm/aframe@1.4.2/dist/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/aframe-ar@1.7.2/dist/aframe-ar.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        .arjs-loader {
            height: 100%;
            width: 100%;
            position: absolute;
            top: 0;
            left: 0;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 9999;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            color: white;
        }
        .arjs-loader div {
            text-align: center;
            font-size: 1.25em;
            margin-top: 10px;
        }
        .info-panel {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
            max-width: 300px;
        }
        .permission-request {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            z-index: 10000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            text-align: center;
            padding: 20px;
        }
        .permission-request button {
            margin-top: 20px;
            padding: 10px 20px;
            font-size: 16px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div class="permission-request" id="permissionRequest">
        <h2>Для работы приложения нужны разрешения</h2>
        <p>Это AR-приложение требует доступ к камере и данным о ориентации устройства.</p>
        <button id="requestPermissionBtn">Разрешить доступ</button>
    </div>

    <div class="arjs-loader">
        <div>Загрузка, пожалуйста подождите...</div>
    </div>

    <div class="info-panel" id="infoPanel" style="display: none;">
        <div><strong>Длина вектора A:</strong> <span id="lengthA">0</span></div>
        <div><strong>Длина вектора B:</strong> <span id="lengthB">0</span></div>
        <div><strong>Угол между векторами:</strong> <span id="angle">0°</span></div>
        <div><strong>Скалярное произведение:</strong> <span id="dotProduct">0</span></div>
        <div><strong>Формула:</strong> A·B = |A||B|cosθ</div>
    </div>

    <a-scene embedded arjs="sourceType: webcam; debugUIEnabled: false;" vr-mode-ui="enabled: false" renderer="logarithmicDepthBuffer: true;">
        <a-entity id="marker" cursor="rayOrigin: mouse" raycaster="objects: .interactive" visible="false">
            <!-- Оси координат -->
            <a-entity position="0 0 0">
                <a-entity geometry="primitive: cylinder; radius: 0.02; height: 1" material="color: #FF0000" rotation="0 0 -90" position="0.5 0 0"></a-entity>
                <a-entity geometry="primitive: cylinder; radius: 0.02; height: 1" material="color: #00FF00" rotation="0 0 0" position="0 0.5 0"></a-entity>
                <a-entity geometry="primitive: cylinder; radius: 0.02; height: 1" material="color: #0000FF" rotation="90 0 0" position="0 0 0.5"></a-entity>
                
                <a-entity text="value: X; color: red; align: center; width: 2" position="1.1 0 0" scale="0.2 0.2 0.2"></a-entity>
                <a-entity text="value: Y; color: green; align: center; width: 2" position="0 1.1 0" scale="0.2 0.2 0.2"></a-entity>
                <a-entity text="value: Z; color: blue; align: center; width: 2" position="0 0 1.1" scale="0.2 0.2 0.2"></a-entity>
            </a-entity>
            
            <!-- Вектор A (красный) -->
            <a-entity id="vectorA" class="interactive" position="0 0 0">
                <a-entity id="cylinderA" geometry="primitive: cylinder; radius: 0.05; height: 1" material="color: #FF5555" rotation="0 0 -90" position="0.5 0 0"></a-entity>
                <a-entity text="value: A; color: white; align: center; width: 2" position="0.5 0.1 0" scale="0.2 0.2 0.2"></a-entity>
                <a-entity class="arrow" geometry="primitive: cone; radiusBottom: 0.1; height: 0.2" material="color: #FF5555" rotation="0 0 -90" position="1 0 0"></a-entity>
            </a-entity>
            
            <!-- Вектор B (синий) -->
            <a-entity id="vectorB" class="interactive" position="0 0 0">
                <a-entity id="cylinderB" geometry="primitive: cylinder; radius: 0.05; height: 1" material="color: #5555FF" rotation="0 0 0" position="0 0.5 0"></a-entity>
                <a-entity text="value: B; color: white; align: center; width: 2" position="0 0.6 0" scale="0.2 0.2 0.2"></a-entity>
                <a-entity class="arrow" geometry="primitive: cone; radiusBottom: 0.1; height: 0.2" material="color: #5555FF" rotation="0 0 0" position="0 1 0"></a-entity>
            </a-entity>
            
            <!-- Дуга угла -->
            <a-entity id="angleArc" visible="false">
                <a-entity geometry="primitive: torus; arc: 30; radius: 0.3; radiusTubular: 0.01" material="color: yellow; opacity: 0.8" rotation="0 0 0"></a-entity>
                <a-entity text="value: θ; color: yellow; align: center; width: 2" position="0.2 0.2 0" scale="0.2 0.2 0.2"></a-entity>
            </a-entity>
        </a-entity>
        
        <a-camera></a-camera>
    </a-scene>

    <script>
        // Запрос разрешений
        document.getElementById('requestPermissionBtn').addEventListener('click', async function() {
            try {
                // Запрос доступа к камере
                const stream = await navigator.mediaDevices.getUserMedia({ video: true });
                stream.getTracks().forEach(track => track.stop());
                
                // Запрос доступа к ориентации (для мобильных устройств)
                if (window.DeviceOrientationEvent) {
                    if (typeof DeviceOrientationEvent.requestPermission === 'function') {
                        const permission = await DeviceOrientationEvent.requestPermission();
                        if (permission !== 'granted') {
                            alert('Для работы приложения необходимо разрешение на доступ к ориентации устройства.');
                            return;
                        }
                    }
                }
                
                // Скрываем запрос разрешений и показываем AR-сцену
                document.getElementById('permissionRequest').style.display = 'none';
                document.querySelector('.arjs-loader').style.display = 'flex';
                
                // Инициализация AR
                initAR();
            } catch (error) {
                console.error('Ошибка при запросе разрешений:', error);
                alert('Не удалось получить необходимые разрешения. Приложение не может работать.');
            }
        });
        
        // Проверяем, нужен ли запрос разрешений
        window.onload = function() {
            // Для iOS 13+ нужно явно запрашивать разрешение
            if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                document.getElementById('permissionRequest').style.display = 'flex';
            } else {
                // Для других устройств сразу запускаем AR
                document.getElementById('permissionRequest').style.display = 'none';
                document.querySelector('.arjs-loader').style.display = 'flex';
                initAR();
            }
        };
        
        function initAR() {
            const scene = document.querySelector('a-scene');
            
            // Ждем, пока сцена будет готова
            scene.addEventListener('loaded', function() {
                const marker = document.getElementById('marker');
                const vectorA = document.getElementById('vectorA');
                const vectorB = document.getElementById('vectorB');
                const cylinderA = document.getElementById('cylinderA');
                const cylinderB = document.getElementById('cylinderB');
                const angleArc = document.getElementById('angleArc');
                const infoPanel = document.getElementById('infoPanel');
                
                // Показываем информационную панель
                infoPanel.style.display = 'block';
                
                // Переменные для хранения состояния
                let isDraggingA = false;
                let isDraggingB = false;
                let startPosition = { x: 0, y: 0 };
                let startRotationA = { x: 0, y: 0, z: 0 };
                let startRotationB = { x: 0, y: 0, z: 0 };
                
                // Функция для обновления информации о векторах
                function updateVectorInfo() {
                    // Получаем текущие направления векторов
                    const directionA = new THREE.Vector3(1, 0, 0).applyQuaternion(vectorA.object3D.quaternion);
                    const directionB = new THREE.Vector3(0, 1, 0).applyQuaternion(vectorB.object3D.quaternion);
                    
                    // Вычисляем длины векторов
                    const lengthA = parseFloat(cylinderA.getAttribute('height'));
                    const lengthB = parseFloat(cylinderB.getAttribute('height'));
                    
                    // Вычисляем угол между векторами
                    const angleRad = directionA.angleTo(directionB);
                    const angleDeg = THREE.MathUtils.radToDeg(angleRad);
                    
                    // Вычисляем скалярное произведение
                    const dotProduct = lengthA * lengthB * Math.cos(angleRad);
                    
                    // Обновляем информационную панель
                    document.getElementById('lengthA').textContent = lengthA.toFixed(2);
                    document.getElementById('lengthB').textContent = lengthB.toFixed(2);
                    document.getElementById('angle').textContent = angleDeg.toFixed(1) + '°';
                    document.getElementById('dotProduct').textContent = dotProduct.toFixed(2);
                    
                    // Обновляем дугу угла
                    if (angleDeg > 5 && angleDeg < 175) {
                        angleArc.setAttribute('visible', 'true');
                        
                        // Позиционируем дугу между векторами
                        const midDirection = new THREE.Vector3()
                            .addVectors(directionA.clone().normalize(), directionB.clone().normalize())
                            .normalize()
                            .multiplyScalar(0.3);
                        
                        angleArc.object3D.position.copy(midDirection);
                        
                        // Поворачиваем дугу
                        const up = new THREE.Vector3(0, 0, 1);
                        const axis = new THREE.Vector3().crossVectors(directionA, directionB).normalize();
                        
                        // Если векторы коллинеарны, используем произвольную ось
                        if (axis.length() < 0.001) {
                            axis.set(0, 0, 1);
                        }
                        
                        const quaternion = new THREE.Quaternion().setFromUnitVectors(
                            new THREE.Vector3(0, 1, 0),
                            axis
                        );
                        
                        angleArc.object3D.quaternion.copy(quaternion);
                        angleArc.setAttribute('geometry', 'arc', angleDeg);
                    } else {
                        angleArc.setAttribute('visible', 'false');
                    }
                }
                
                // Обработчики событий для вектора A
                vectorA.addEventListener('mousedown', function(evt) {
                    isDraggingA = true;
                    startPosition = { x: evt.detail.intersection.point.x, y: evt.detail.intersection.point.y };
                    startRotationA = vectorA.object3D.rotation.clone();
                });
                
                // Обработчики событий для вектора B
                vectorB.addEventListener('mousedown', function(evt) {
                    isDraggingB = true;
                    startPosition = { x: evt.detail.intersection.point.x, y: evt.detail.intersection.point.y };
                    startRotationB = vectorB.object3D.rotation.clone();
                });
                
                // Обработчик движения для всей сцены
                scene.addEventListener('mousemove', function(evt) {
                    if (!isDraggingA && !isDraggingB) return;
                    
                    const intersection = evt.detail.intersection;
                    if (!intersection) return;
                    
                    const currentPosition = { x: intersection.point.x, y: intersection.point.y };
                    const deltaX = currentPosition.x - startPosition.x;
                    const deltaY = currentPosition.y - startPosition.y;
                    
                    if (isDraggingA) {
                        // Вращаем вектор A
                        const newRotationX = startRotationA.x - deltaY * 2;
                        const newRotationZ = startRotationA.z + deltaX * 2;
                        
                        vectorA.object3D.rotation.set(
                            THREE.MathUtils.clamp(newRotationX, -Math.PI/2, Math.PI/2),
                            0,
                            THREE.MathUtils.clamp(newRotationZ, -Math.PI/2, Math.PI/2)
                        );
                    }
                    
                    if (isDraggingB) {
                        // Вращаем вектор B
                        const newRotationX = startRotationB.x + deltaY * 2;
                        const newRotationZ = startRotationB.z - deltaX * 2;
                        
                        vectorB.object3D.rotation.set(
                            THREE.MathUtils.clamp(newRotationX, -Math.PI/2, Math.PI/2),
                            0,
                            THREE.MathUtils.clamp(newRotationZ, -Math.PI/2, Math.PI/2)
                        );
                    }
                    
                    updateVectorInfo();
                });
                
                // Обработчик отпускания кнопки мыши
                scene.addEventListener('mouseup', function() {
                    isDraggingA = false;
                    isDraggingB = false;
                });
                
                // Обработчик изменения размера векторов (жест pinch/zoom)
                let initialDistance = 0;
                let initialHeightA = 1;
                let initialHeightB = 1;
                
                scene.addEventListener('touchstart', function(evt) {
                    if (evt.touches.length === 2) {
                        initialDistance = Math.hypot(
                            evt.touches[0].clientX - evt.touches[1].clientX,
                            evt.touches[0].clientY - evt.touches[1].clientY
                        );
                        initialHeightA = parseFloat(cylinderA.getAttribute('height'));
                        initialHeightB = parseFloat(cylinderB.getAttribute('height'));
                    }
                });
                
                scene.addEventListener('touchmove', function(evt) {
                    if (evt.touches.length === 2 && !isDraggingA && !isDraggingB) {
                        const currentDistance = Math.hypot(
                            evt.touches[0].clientX - evt.touches[1].clientX,
                            evt.touches[0].clientY - evt.touches[1].clientY
                        );
                        
                        const scale = currentDistance / initialDistance;
                        
                        // Изменяем длину вектора A
                        let newHeightA = initialHeightA * scale;
                        newHeightA = THREE.MathUtils.clamp(newHeightA, 0.1, 3);
                        cylinderA.setAttribute('height', newHeightA);
                        cylinderA.setAttribute('position', { x: newHeightA/2, y: 0, z: 0 });
                        vectorA.querySelector('.arrow').setAttribute('position', { x: newHeightA, y: 0, z: 0 });
                        
                        // Изменяем длину вектора B
                        let newHeightB = initialHeightB * scale;
                        newHeightB = THREE.MathUtils.clamp(newHeightB, 0.1, 3);
                        cylinderB.setAttribute('height', newHeightB);
                        cylinderB.setAttribute('position', { x: 0, y: newHeightB/2, z: 0 });
                        vectorB.querySelector('.arrow').setAttribute('position', { x: 0, y: newHeightB, z: 0 });
                        
                        updateVectorInfo();
                    }
                });
                
                // Инициализация информации
                updateVectorInfo();
                
                // Скрываем loader, когда маркер обнаружен
                marker.addEventListener('markerFound', function() {
                    document.querySelector('.arjs-loader').style.display = 'none';
                });
                
                marker.addEventListener('markerLost', function() {
                    document.querySelector('.arjs-loader').style.display = 'flex';
                });
            });
        }
    </script>
</body>
</html>
